# 一、C++的模版

## 1、泛型编程

### （1）概念

编写不依赖具体数据类型的程序

### （2）目标

- 将程序尽可能通用
- 将算法从数据结构中抽象出来

### （3）应用

- c++模版为范型程序设计提供了基础
- STL（标准模版库 Standard Template Library）是范型程序设计的例子

## 2、模板简介

### （1）什么是模版

模板是支持参数化多态的工具，是一种对类型进行参数化的工具

### （2）模板分类

- 函数模版

  针对参数类型不同的函数

- 类模板

  针对仅数据成员和成员函数类型不同的类

### （3）工作方式

模版只是说明，需要实例化后才能执行和使用

- 函数模板 -> 模板函数
- 类模板 -> 模板类 -> 对象

`->`：实例化

> 模板的声明和定义只能在全局、命名空间或类范围内进行
>
> 即不能在局部范围、函数内进行

## 3、函数模板

### （1）概念

所谓函数模板，就是一个通用函数，返回值和参数类型不具体指定，使用虚拟类型来替代（占位符），这个通用函数就叫函数模版（Function Template）

### （2）定义形式

- 一

  ```tex
  template<typename 类型参数>
  返回类型 函数名(模版形参表)
  {
  	函数体
  }
  ```

- 二

  ```tex
  template<class T>
  返回类型 函数名(模版形参表)
  {
  	函数体
  }
  ```

> template：声明模板的关键字
>
> typename和class都是表示他们之后的参数都是一个类型的参数，class是早期c++版本使用的

### （3）代码示例

```c++
template<typename T>
T doSum(T a, T b) {
    T temp = a + b;
    return temp;
}

int main() {
    int m = doSum(10 ,20);
    float n = doSum(10.1, 20.2);
    cout << m << "  " << n << endl;
}
```

### （4）重载

- 函数模版支持函数重载，参数列表不一样

- 编译器调用函数的顺序

  1、先搜索参数完全匹配的普通函数

  2、其次搜索参数匹配的模版函数

  3、最后搜索自动类型转换后能匹配的普通函数

## 4、类模板

### （1）简介

建立一个通用类

### （2）代码具体实现格式

```c++
// 声明类以及方法
template<typename T>
class Test {
public:
    bool deleteEle(T data);
};

// 类外定义方法
template<typename T>
bool Test<T>::deleteEle(T data) {
    cout << data << endl;
    return false;
}
```

# 二、STL

## 1、简介

### （1）简单介绍

- 标准模版库

- 一些“容器”的集合：list、vector、set、map等等

- 标准化组件，实现可重用

- 六大部分

  容器、迭代器、空间配置器、配接器、算法、仿函数

### （2）详解

- 容器

  一些封装数据结构的模板类，如：vector、list

- 算法

  大量数据结构算法

- 迭代器

  对容器中数据的读写通过迭代器实现

- 函数对象

  将运算符重载为成员函数，这个类就称为函数对象类

- 适配器

  将一个类的接口适配成用户指定的形式

- 内存分配器

  内存申请和释放

### （3）代码示例

```c++
int main() {
    int a[6] = {26, 5, 76, 1, 6, 3};
    vector<int, allocator<int>> vi(a, a + 6);
    cout << count_if(vi.begin(), vi.end(), not1(bind2nd(less<int>(), 40)));
}
```

- (a, a + 6)

  赋予初值

- vector：container（容器）

- allocator<int>：allocator（分配器）

  默认会有对应规则

- count_if：algorithms（算法）

  查询符合条件的元素个数

- vi.begin()、vi.end()：iterators（迭代器）

- not1、bind2nd：函数适配器

  not1：取反，统计大于等于40的数

- less<int>：函数对象

  查找所有小于int的数据，通过bind2nd：绑定40，查找所有小于40的数

## 2、容器

### （1）简介

- Sequence Container（序列式容器）

  Array、Vectror、Deque、List、Forward-List

- Associative Container（关联容器：key-value）

  set（红黑树）、map、multiset/multimap

- Unsorted Container（无定式容器，本质hash map）

  通过Hash表的链地址法进行查找操作

### （2）vector

#### a、简单介绍

封装了动态大小数组的顺序容器

功能：

- 动态数组
- 尾端增删元素

#### b、函数API

[C++中文- API参考文档](https://www.apiref.com/cpp-zh/cpp/container/vector.html)

- 创建vector

  ```c++
  // 创建vector
  vector<int> v1;
  vector<int> v2(v1);
  vector<int> v3(10, -1);
  vector<string> v4(10, "hi");
  ```

- 基本使用

  ```c++
  int a[5] = {1, 2, 3, 4, 5};
  // 本质为一个模板类
  // 半开区间：[&a[0], &a[5])
  vector<int> vt(&a[0], &a[5]);
  // 1 第一个元素
  cout << "first data = " << vt.front() << endl;
  // 2 最后一个元素
  cout << "last data = " << vt.back() << endl;
  // 3 元素个数
  cout << "data size = " << vt.size() << endl;
  // 4 输出数组
  for (int i = 0; i < vt.size(); ++i)
  {
    cout << vt[i] << " ";
  }
  cout << endl;
  ```

#### c、迭代器

- 简介：

  迭代器是一个复杂的指针，可以读写容器中的对象，本质为运算符的重载

- 格式：

  `vector<int>::iterator iterator = vt.begin();`

- 使用范例

  ```c++
  vector<int>::iterator it;
  for(it = vt.begin(); it != vt.end(); ++it)
  {
    cout << *it << endl;
  }

#### d、底层剖析



# 三、设计模式

# 四、explict关键字

