# 1、Redis为什么这么快？

https://juejin.cn/post/6978280894704386079

- 基于内存实现省去了磁盘IO的消耗

- 底层实现了高效的数据结构

- 合理的数据编码

- 合理的线程模型

  单线程（避免了上下文切换和竞争锁的切换）：是指Redis网络IO和键值对读写是由一个线程来完成的，其他诸如持久化、异步删除、集群数据同步由额外的线程执行

- I/O多路复用

  I/O：网络IO

  多路：多个网络连接

  复用：复用同于一个线程

  是一种同步的IO模型，实现一个线程可以监视多个文件句柄

- 虚拟内存机制

# 2、Redis的数据类型有哪些，底层怎么实现？

- 字符串：整数值、embstr编码的简单动态字符串、简单动态字符串（SDS）
- 列表：压缩列表、双端队列
- 哈希：压缩列表、字典
- 集合：整数集合、字典
- 有序集和：压缩列表、跳跃表、字典

# 3、Redis是单线程的，但是为什么这么高效呢？

虽然Redis文件事件处理器以单线程方式运行，但是通过使用I/O多路复用程序来监听多个套接字

文件事件处理器既实现了高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程运行的模块进行对接，这保持了Redis内部单线程设计的简单性

# 4、如何保证Redis的高可用

- 单点故障：

  实际生产中，如果 redis 只部署一个节点，当机器故障时，整改服务都不能提供服务了

  部署了多台，一台故障时，整个系统依然对外提供服务，这样就提高了服务的可用性

redis 高可用的三种模式：主从模式、哨兵模式、集群模式

## （1）主从模式

优点：

- 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离
- 为了分载 Master 的读操作压力，Slave 服务器可以为客户端提供只读操作的服务，写服务依然必须由 Master 来完成
- Slave 同样可以接受其他 Slaves 的连接和同步请求，这样可以有效地分载 Master 的同步压力
- Master 是以非阻塞的方式为 Slaves 提供服务。所以在 Master-Slave 同步期间，客户端仍然可以提交查询或修改请求
- Slave 同样是以阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis 则返回同步之前的数据

缺点：

- Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复
- 主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性
- 如果多个 Slave 断线了，需要重启的时候，尽量不要在同一时间段进行重启。因为只要 Slave 启动，就会发送 sync 请求和主机全量同步，当多个 Slave 重启的时候，可能会导致 Master IO 剧增从而宕机
- Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂
- Redis 的主节点和从节点中的数据是一样的，降低的内存的可用性

## （2）哨兵模式

## （3）集群模式