## 一、TCP分片和UDP分片

### 1、为什么？

数据报太大，拆分成小数据包

### 2、怎么做？

#### （1）TCP分片是在传输层

如果在IP层分片，如果当一个IP包丢失，那么整个IP报文的所有分片都得重传

TCP是由超时重传机制，重传丢失的TCP报文

#### （2）UDP是在IP层

UDP传输不可靠



## 二、第二次握手丢失情况

重传5次

- 客户端角度

  认为第一次握手SYN报文丢失或者第二次握手ACK-SYN报文，会重传SYN请求连接报文

- 服务器角度

  没有收到第三次ACK报文，认为第二次握手ACK-SYN报文或者第三次ACK丢失，会重传第二次握手ACK-SYN报文



## 三、进程的上下文切换

实际上linux内核中，进程上下文包括进程的虚拟地址空间和硬件上下文

### 1、是什么？

分配CPU资源的一个过程，一个运行的进程切换到另外一个进程去运行

### 2、为什么？

为了使得计算机能够并发执行多个进程

### 3、怎么做？

先保存当前进程的PCB状态，再加载下一个进程的PCB状态



## 四、线程池

线程池参数、线程池拒绝策略和等待队列类型之间的关系

拒绝策略

- 直接抛弃
- 抛弃最老的
- 丢弃抛异常的
- 当前线程直接执行



## 五、MySQL日志

binlog、redo log、undo log

binlog（归档）：记录对数据库进行修改的更新操作，用于数据库的同步和恢复（比如主从数据库之间使用bin log进行同步），只在事务结束时写入

redo log（重做）：记录InnoDB引擎的事务，保证事物的持久性，执行过程中会不断写入

undo log（回滚）：undo log会记录数据的版本，可以实现事务的回滚，回滚到某个版本的数据，实现MVCC



## 六、主从复制

### 1、是什么？

**MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点**。MySQL 默认采用**异步复制**方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表

### 2、为什么？

- 读写分离
- 数据的实时备份
- 高可用

### 3、怎么做？

增量发送

主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程（log dump 线程）根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position（bin-log中的下一个指定更新位置）



## 七、死锁问题

### 1、什么是死锁？

死锁是指两个或以上进程在执行过程中，由于资源竞争造成的一种阻塞现象，若无外力作用，将一直阻塞下去。我们称这种现象为系统产生了死锁或者系统处于死锁状态

### 2、产生死锁的原因有哪些？

- 系统资源不足
- 程序执行顺序不当
- 资源分配不当

### 3、产生死锁的必要条件

- 互斥条件

  一个资源只能被一个进程使用

- 请求与保持条件

  请求资源阻塞时，对已获得的资源并不释放

- 不剥夺条件

  进程已获得的资源，除非自己释放，否则不能被剥夺

- 循环等待条件

  进程之间形成一种头尾相接的资源等待关系

### 4、如何解决死锁？

在系统设计、进程调度等方面注意不要让四个必要条件成立，确定合理的资源分配算法、防止进程处于等待状态下占用资源

## 八、TCP协议如何保证可靠传输

https://segmentfault.com/a/1190000022944999

通过下面几种机制共同保证可靠传输

### 1、数据块划分

应用数据被划分为TCP认为合适发送的数据块

### 2、数据排序

TCP会对每个数据进行编号，接收端对收到的数据进行排序，将有序的数据传给应用层

### 3、校验和

发送端和接收端分别计算数据的数据的校验和，如果数据有差错就丢弃

### 4、数据包去重

丢弃重复接收的数据

### 5、超时重传

当TCP发出一个段后，会启动一个定时器，等待接收方会送确认报文，如果不能及时收到一个确认就重传

### 6、流量控制

连接双方都有固定大小的缓冲区，接收端只允许发送端发送接收段缓冲区大小的数据，当接收方来不及处理发送方发送的确认数据时候，会提示发送方降低发送速率。TCP使用滑动窗口协议实现流量控制

### 7、拥塞避免

- 慢开始
- 拥塞避免
- 快重传和快恢复

### 8、ARQ协议

发送完一个分组就停止等待确认报文，收到确认报文后在发送下一个分组数据



## 九、Redis为什么这么快？

https://juejin.cn/post/6978280894704386079

- 基于内存实现省去了磁盘IO的消耗

- 底层实现了高效的数据结构

- 合理的数据编码

- 合理的线程模型

  单线程（避免了上下文切换和竞争锁的切换）：是指Redis网络IO和键值对读写是由一个线程来完成的，其他诸如持久化、异步删除、集群数据同步由额外的线程执行

- I/O多路复用

  I/O：网络IO

  多路：多个网络连接

  复用：复用同于一个线程

  是一种同步的IO模型，实现一个线程可以监视多个文件句柄

- 虚拟内存机制