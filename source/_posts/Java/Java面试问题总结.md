---
title: Java面试题总结
date: 2021-01-19
tags: [Java面试]
categories: Java
---

### 1、高并发中的集合有哪些问题

- 第一代线程安全集合类

Vector、Hashtable

使用synchronized修饰方法，效率低下



- 第二代线程非安全集合类

ArrayList、HashMap

线程不安全但是性能好



- 第三代线程安全集合类

在大量并发情况下如何提高集合的效率和安全呢

Java容器、Java的发展历史



### 2、JDK1.8的新特性有哪些

#### 一、接口的默认方法

#### 二、Lambda表达式

#### 三、函数式接口

#### 四、方法与构造函数引用

#### 五、Lambda作用域

#### 六、访问局部变量

#### 七、访问对象字段于静态变量

#### 八、访问接口的默认方法



### 3、Java抽象类和接口有什么区别

语法与语意的区别

什么时候用抽象类，什么时候用接口

抽象类 -> 有一种既有抽象概念（植物、动物）

接口 -> 共同特征（例如具有某种会飞的功能）



#### 相同点：

- 都不能被实例化
- 接口的实现类和抽象类的子类都只有在实现了接口或抽象类中的方法以后才能被实例化

#### 不同点：

- 接口中的方法只有定义（JDK1.8中可以有default方法），抽象类的方法可以定义与实现

- 关键字不同：`implement`和`extends`，类可以实现多个接口，但只能继承一个类

- 接口强调功能的实现，抽象类强调所属关系

- 接口中的成员变量默认都是` public static final`，必须初始化，不可被修改

  抽象类的成员变量默认是default，可以被重新定义，也可以被修改

- 接口中的成员方法都是` public、abstract`的

  抽象方法都是要被` abstract`修饰的不能被` private、synchronized、native`等修饰，不带花括号



### 4、ACID是靠什么来保证的

ACID（数据库事务正确执行的四个基本要素的缩写）

> 原子性、一致性、隔离性、持久性

#### 原子性

undolog



#### 一致性

由其他三个特性来保证的



#### 隔离性

MVVC



#### 持久性

redolog



### 5、HashMap底层原理

https://zhuanlan.zhihu.com/p/79507868



### 6、BeanFactory和ApplicationContext的区别

https://juejin.cn/post/6844903877574131726

<img src="https://cos-1301609895.cos.ap-nanjing.myqcloud.com/Java/BeanFactory%E5%92%8CApplicationContext%E7%9A%84%E5%8C%BA%E5%88%AB1.jpg" align=left width=800>

<img src="https://cos-1301609895.cos.ap-nanjing.myqcloud.com/Java/BeanFactory%E5%92%8CApplicationContext%E7%9A%84%E5%8C%BA%E5%88%AB2.jpg" align=left  width=800>



### 7、HashMap和HashTable的区别

- HashTable线程同步但效率低，HashMap相反但效率高

  线程同步：指的是多线程的时候数据的安全性，synchronized关键字

- HashTable不允许<key, value>空值，HashMap允许

- HashTable使用Enumeration，HashMap使用Iterator

- HashTable（默认为11）扩容方式：2*old+1，HashMap（默认为16）扩容方式为：2的指数倍

- HashTable继承自Dictionary类，HashMap继承自AbstractMap类



### 8、HashMap有哪些线程安全的方式

方法一：

通过`Collections.synchronizedMap()`返回一个新的Map，这个新的Map就是线程安全的。这个要求大家习惯基于接口编程，因为返回的并不是HashMap，而是一个Map实现。

方法二：

重新改写了HashMap，具体可以查看`java.util.concurrentHashMap`，是一个支持并发的HashMap。这个方法比方法一有了很大的改进。



### 9、HashMap在扩容上做了哪些处理

JDK1.8不需要再像JDK1.7一样重新计算hash，只需要看原来的hash值新增的那一位bit是1还是0就好



### 10、MVCC解决的问题到底是啥

MVCC：多版本并发控制（常常用在数据库里的技术）

数据库并发场景有三种：

- 读读

  不存在任何问题，无需并发控制

- 读写

  有线程安全，可能会造成事务的隔离性问题，可能遇到脏读、幻读、不可重复读

- 写写

  有线程安全问题，可能存在更新丢失问题

**脏读（读取未提交数据）**：脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的，值得注意的是，脏读一般是针对于update操作的。

**幻读（前后多次读取，数据总量不一致）**：事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。

**不可重复读（前后多次读取，数据内容不一致）**：事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。

**不可重复读和幻读到底有什么区别呢？**

(1) 不可重复读是读取了其他事务更改的数据，**针对update操作**

解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。

(2) 幻读是读取了其他事务新增的数据，**针对insert和delete操作**

解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。



MVCC为事务分配单项增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读事务开始前的数据库快照，所以MVCC可以为数据解决以下问题：

​	1、在并发读写数据库时，可以在读操作时不阻塞写操作，写操作也不阻塞读操作，提高了数据库并发读写的能力

​	2、解决脏读、幻读、不可重复读等事务隔离问题，但是不能解决更新丢失问题



### 10、MVCC实现原理



### 11、Mybatis插件运行原理和开发流程



### 12、Mybatis的优缺点

#### 优点：

- 1、简单易学，容易上手，基于SQL编程
- 2、与JDBC相比，减少了代码量，消除了大量冗余代码，不需要手动开关闭
- 3、与各种的数据库兼容（使用JDBC来连接数据库）
- 4、提供了很多第三方插件（分页插件/逆向工程：反向生成实体类）
- 5、与Spring很好的集成
- 6、相当灵活SQL写在XML文件里，与代码相分离解耦，便于管理与优化，还可以重用
- 7、提供XML标签，支持编写动态SQL语句
- 8、提供映射标签，支持对象与数据库的ORM字段关系映射
- 9、提供对象映射标签，支持对象关系组建维护



#### 缺点

- 1、SQL语句的编写量巨大
- 2、SQL语句依赖数据库，导致数据库移植性差，不能随意更换数据库



### 13、Mybatis中`#{}`和`${}`区别

- `#{}`是预编译处理，`${}`是字符串替换
- Mybatis在处理`#{}`时，会将`#{}`替换为?，调用`PreparedStatement`的`set`方法来赋值
- Mybatis在处理`¥{}`时，直接将`¥{}`替换成变量的值
- 前者可以有效防止SQL注入



## 数据库

### 1、MySQL的隔离级别有哪些？

https://www.cnblogs.com/fengzheng/p/12557762.html

首先我们来看看隔离级别是个玩意

有四种隔离级别

1. 读未提交（READ UNCOMMITTED）

   所有事务都可以看到未提交事务的执行结果

2. 读提交 （READ COMMITTED）

   一个事务开始时，只能看到已经提交事务所做的改变

3. 可重复读 （REPEATABLE READ）

   ？？？

4. 串行化 （SERIALIZABLE）

   通过强制事务排序

| 隔离级别 | 脏读   | 不可重复读 | 幻读   |
| -------- | ------ | ---------- | ------ |
| 读未提交 | 可能   | 可能       | 可能   |
| 读提交   | 不可能 | 可能       | 可能   |
| 可重复读 | 不可能 | 不可能     | 可能   |
| 串行化   | 不可能 | 不可能     | 不可能 |



### 2、MySQL的复制原理

现在主流的项目中，需要多个MySQL数据库，所以需要保持所有数据库的一致性



### 3、MySQL索引

https://www.cnblogs.com/zsql/p/13808417.html

- 聚簇和非聚簇索引的区别

索引存在于磁盘，MySQL的索引类型与存储引擎是相关的，innobd存储引擎数据文件和索引文件全都放在ibd文件中，而myisam的数据文件全都放在myd文件中，索引放在myi文件中，判断条件：数据和索引是否是分开的

- 索引的基本原理

1、为什么要有索引？

一般的应用系统中，读写比例为10:1，而且插入和一般的更新操作很少出现性能问题

生产环境中，我们遇到最多的也是最容易出问题的，是一些复杂的查询操作

索引就是为了进行高速查询



2、什么是索引？

索引在MySQL中也叫一种“键”，是存储引擎用于快速找到记录的一种数据结构

索引对于良好的性能非常关键，尤其是当表的数据量愈发巨大时，索引对于性能的影响愈发巨大

索引就相当于字典的音序表、



3、索引的原理



4、索引的数据结构

MySQL主要用到两种结构：B+Tree索引和Hash索引

Inodb存储引擎默认是B+Tree索引

Memory存储引擎默认是Hash索引



## 计算机网络





## 操作系统

### 1、页面置换算法

进程运行时，若其访问的页面不在内存而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区

#### A、四种页面置换算法

##### 最佳置换算法（OPT）

该算法选择淘汰的页面是以后不会使用的，或者是最长时间内不再被访问的页面，以此来保证最低的缺页率

由于无法预知，所以该算法无法实现



##### 先进先出（FIFO）

优先淘汰最早进入内存的页面

将掉入内存的页面按照先后次序排成一个队列，设置一个指针指向总指向最早的界面

有些页面会经常被访问，所以不适用



##### 最近最久未使用（LRU）

选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问

为每个页面设置一个访问字段记录自从上次访问以来所经历的时间，淘汰页面时选择访问字段值最大的一个淘汰

性能比较好，但是需要寄存器和栈的支持，实现起来开销比较大



##### 时钟（CLOCK）

简单的CLOCK算法是给每一帧关联一个附加位，称为使用位

当某一页首次装入主存时，该帧的使用位设置为1；当该页随后再被访问到时，它的使用位也被置为1

每当需要淘汰页面时就寻找使用位为0的页面，并将经过的页面置为0